# General

## [atoi](./code/atoi.kt)
Implement atoi which converts a string to an integer.

## [Even Num of Digits](./code/evenNumOfDigits.kt)
Given an array nums of integers, return how many of them contain an even number of digits.

## [intToRoman](./code/intToRoman.kt)
Given an integer, convert it to a roman numeral.

## [Length of Longest Substring](./code/lengthOfLongestSubstring.kt)
Given string `s`. Find length of the longest substring without repeating characters.

## [Longest Common Prefix](./code/longestCommonPrefix.kt)
Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "".

## [Max Volume](./code/maxVolume.kt)
Given `n` non-negative integers `a1, a2, ..., an` , where each represents a point at coordinate `(i, ai)`. `n` vertical lines are drawn such that the two endpoints of the line `i` is at `(i, ai)` and `(i, 0)`. Find two lines, which, together with the `x`-axis forms a container, such that the container contains the most water. Notice that you may not slant the container

## [romanToInt](./code/romanToInt.kt)
Given a roman numeral, convert it to an integer.

## [Sum of Two](./code/sumOfTwo.kt)
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

## [Zig Zag Convert](./code/zigZagConvert.kt)
Write the code that will take a string and make this conversion given a number of rows.

## [Restore String](./code/restoreString.kt)
Given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string. Return the shuffled string.

## [Maximum Nesting Depth](./code/maximumNestingDepth.kt)
Given a VPS represented as string `s`, return the nesting depth of `s`.

## [XOR Operation in Array](./code/xorOperationInArray.kt)
Given an integer `n` and an integer start. Define an array `nums` where `nums[i] = start + 2*i` (`0` indexed) and `n == nums.length`. Return the bitwise XOR of all elements of `nums`.

## [ParkingSystem](./code/ParkingSystem.kt)
Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.

## [Remove Outer Parentheses](./code/removeOuterParentheses.kt)
Given a valid parentheses string `S`, consider its primitive decomposition: `S = P_1 + P_2 + ... + P_k`, where `P_i` are primitive valid parentheses strings. Return `S` after removing the outermost parentheses of every primitive string in the primitive decomposition of `S`.

## [OrderedStream](./code/OrderedStream.kt)
There is a stream of `n` (`id`, `value`) pairs arriving in an arbitrary order, where `id` is an integer between `1` and `n` and value is a string. No two pairs have the same `id`. Design a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values.

## [Matrix Diagonal Sum](./code/matrixDiagonalSum.kt)
Given a square matrix `mat`, return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.

## [Array Pair Sum](./code/arrayPairSum.kt)
Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ...,(an, bn)` such that the sum of `min(ai, bi)` for all `i` is maximized. Return the maximized sum.

## [Freq ALphabets](./code/freqAlphabets.kt)
Given a string s formed by digits (`'0'` - `'9'`) and `'#'` . We want to map s to English lowercase characters as follows: Characters (`'a'` to `'i'`) are represented by (`'1'` to `'9'`) respectively. Characters (`'j'` to `'z'`) are represented by (`'10#'` to `'26#'`) respectively. Return the string formed after mapping. It's guaranteed that a unique mapping will always exist.

## [RecentCounter](./code/RecentCounter.kt)
You have a `RecentCounter` class which counts the number of recent requests within a certain time frame. Implement the `RecentCounter` class

## [Reverse String](./code/reverseString.kt)
Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters.

## [Unique Occurrences](./code/uniqueOccurrences.kt)
Given an array of integers arr, write a function that returns true if and only if the number of occurrences of each value in the array is unique.

## [Remove Duplicates](./code/removeDuplicates.kt)
Given a string `S` of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them. We repeatedly make duplicate removals on S until we no longer can. Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.

## [Find Lucky](./code/findLucky.kt)
Given an array of integers `arr`, a lucky integer is an integer which has a frequency in the array equal to its value. Return a lucky integer in the array. If there are multiple lucky integers return the largest of them. If there is no lucky integer return `-1`.

## [Transpose Matrix](./code/transposeMatrix.kt)
Given a matrix `A`, return the transpose of `A`. The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.

## [Distribute Candidates](./code/distributeCandies.kt)
We distribute some number of candies, to a row of `n = num_people people` in the following way: We then give `1` candy to the first person, `2` candies to the second person, and so on until we give n candies to the last person. Then, we go back to the start of the row, giving `n + 1` candies to the first person, `n + 2` candies to the second person, and so on until we give `2 * n` candies to the last person. This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift). Return an array (of length num_people and sum candies) that represents the final distribution of candies.

## [Group Anagrams](./code/groupAnagrams.kt)
Given an array of strings `strs`, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

## [Find K Closest Elements](./code/findKClosestElements.kt)
Given a sorted integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order.

## [Is Valid Sudoku](./code/isValidSudoku.kt)
Determine if a `9 x 9` Sudoku board is valid

## [Pemutation in String](./code/permutationInString.kt)
Given two strings `s1` and `s2`, return true if `s2` contains a permutation of `s1`, or false otherwise. In other words, return true if one of `s1`'s permutations is the substring of `s2`.

## [Longest Turbulent Subarray](./code/longestTurbulentSubarray.kt)
Given an integer array `arr`, return the length of a maximum size turbulent subarray of `arr`. A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.

## [Spiral Matrix](./code/spiralMatrix.kt)
Given an `m x n` matrix, return all elements of the matrix in spiral order.

## [Find All Duplicates](./code/findAllDuplicates.kt)
Given an integer array nums of length `n` where all the integers of nums are in the range `[1, n]` and each integer appears once or twice, return an array of all the integers that appears twice.

## [Best Time to Buy Stocks](./code/bestTimeToBuyStocks.kt)
You are given an integer array prices where `prices[i]` is the price of a given stock on the `i`th day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.

## [Can Be Valid](./code/canBeValid.kt)
A parentheses string is a non-empty string consisting only of `'('` and `')'`. It is valid if any of the following conditions is true: 1) It is `()`; 2) It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid parentheses strings. 3) It can be written as `(A)`, where `A` is a valid parentheses string. You are given a parentheses string `s` and a string `locked`, both of length `n`. `locked` is a binary string consisting only of `'0'`s and `'1'`s. For each index `i` of locked, if `locked[i]` is `'1'`, you cannot change `s[i]`. But if `locked[i]` is `'0'`, you can change `s[i]` to either `'('` or `')'`. Return `true` if you can make s a valid parentheses string. Otherwise, return `false`.

## [Find Min Arrow Shots](./code/findMinArrowShots.kt)
Given the array `points`, return the minimum number of arrows that must be shot to burst all balloons.

## [Can Place Flowers](./code/canPlaceFlowers.kt)
You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing `0`'s and `1`'s, where `0` means empty and `1` means not empty, and an integer `n`, return if `n` new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.

## [Can Complete Circuit](./code/canCompleteCircuit.kt)
There are `n` gas stations along a circular route, where the amount of gas at the `i`th station is `gas[i]`. You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `i`th station to its next `(i + 1)`th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays `gas` and `cost`, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return `-1`.

## [Number of Arrays](./code/numberOfArrays.kt)
You are given a `0`-indexed array of `n` integers `differences`, which describes the differences between each pair of consecutive integers of a hidden sequence of length `(n + 1)`. More formally, call the hidden sequence `hidden`, then we have that `differences[i] = hidden[i + 1] - hidden[i]`. You are further given two integers `lower` and `upper` that describe the inclusive range of values `[lower, upper]` that the `hidden` sequence can contain. Return the number of possible hidden sequences there are. If there are no possible sequences, return `0`.

## [Sequential Digits](./code/sequentialDigits.kt)
An integer has sequential digits if and only if each digit in the number is one more than the previous digit. Return a sorted list of all the integers in the range `[low, high]` inclusive that have sequential digits.

## [Maximum Difference](./code/maximumDifference.kt)
Given a `0`-indexed integer array nums of size `n`, find the maximum difference between `nums[i]` and `nums[j]` (i.e., `nums[j] - nums[i]`), such that `0 <= i < j < n` and `nums[i] < nums[j]`. Return the maximum difference. If no such i and j exists, return `-1`.

## [Find Anagrams](./code/findAnagrams.kt)
Given two strings `s` and `p`, return an array of all the start indices of `p`'s anagrams in `s`. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

## [isAnagram](./code/isAnagram.kt)
Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

## [Find Max Length](./code/findMaxLength.kt)
Given a binary array `nums`, return the maximum length of a contiguous subarray with an equal number of `0` and `1`.

## [Find the Difference](./code/findTheDifference.kt)
You are given two strings `s` and `t`. String t is generated by random shuffling string `s` and then add one more letter at a random position. Return the letter that was added to `t`.

## [Add Digits](./code/addDigits.kt)
Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it.

## [Find Pairs](./code/findPairs.kt)
Given an array of integers `nums` and an integer `k`, return the number of unique `k`-diff pairs in the array.

## [Subarray Sum](./code/subarraySum.kt)
Given an array of integers `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals to `k`.

## [Check Inclusion](./code/checkInclusion.kt)
Given two strings `s1` and `s2`, return `true` if `s2` contains a permutation of `s1`, or `false` otherwise. In other words, return `true` if one of `s1`'s permutations is the substring of `s2`.

## [Subsets](./code/subsets.kt)
Given an integer array `nums` of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.

## [Is Palindrome](./code/isPalindrome.kt)
Given a string `s`, return `true` if it is a palindrome, or `false` otherwise.

## [Convert to Title](./code/convertToTitle.kt)
Given an integer `columnNumber`, return its corresponding column title as it appears in an Excel sheet.

## [Title to Number](./code/titleToNumber.kt)
Given a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number.

## [Is Isomorphic](./code/isIsomorphic.kt)
Given two strings `s` and `t`, determine if they are isomorphic.

## [Contains Duplicate](./code/containsDuplicate.kt)
Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

## [Contains Nearby Duplicate](./code/containsNearbyDuplicate.kt)
Given an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and `abs(i - j) <= k`.

## [Longest Palindrome](./code/longestPalindrome.kt)
Given a string `s`, return the longest palindromic substring in `s`.

## [Count Pairs](./code/countPairs.kt)
Given a `0`-indexed integer array `nums` of length `n` and an integer `k`, return the number of pairs `(i, j)` where `0 <= i < j < n`, such that `nums[i] == nums[j]` and `(i * j)` is divisible by `k`.

## [Maximum Even Split](./code/maximumEvenSplit.kt)
You are given an integer `finalSum`. Split it into a sum of a maximum number of unique positive even integers. Return a list of integers that represent a valid split containing a maximum number of integers. If no valid split exists for `finalSum`, return an empty list. You may return the integers in any order.

## [Compare Version](./code/compareVersion.kt)
Given two version numbers, `version1` and `version2`, compare them.

## [Min Step](./code/minStep.kt)
You are given two strings `s` and `t`. In one step, you can append any character to either `s` or `t`. Return the minimum number of steps to make `s` and `t` anagrams of each other.

## [Summary Ranges](./code/summaryRanges.kt)
You are given a sorted unique integer array `nums`. Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of `nums` is covered by exactly one of the ranges, and there is no integer `x` such that `x` is in one of the ranges but not in `nums`.

## [MyQueue](./code/MyQueue.kt)
Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).

## [Reverse Vowels](./code/reverseVowels.kt)
Given a string `s`, reverse only all the vowels in the string and return it.

## [Is Subsequence](./code/isSubsequence.kt)
Given two strings `s` and `t`, return `true` if `s` is a subsequence of `t`, or `false` otherwise.

## [Four Sum](./code/fourSum.kt)
Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

    0 <= a, b, c, d < n
    a, b, c, and d are distinct.
    nums[a] + nums[b] + nums[c] + nums[d] == target

You may return the answer in any order.

## [Count Odds](./code/countOdds.kt)
Given two non-negative integers `low` and `high`. Return the count of odd numbers between `low` and `high` (inclusive).

## [Average Salary](./code/averageSalary.kt)
You are given an array of unique integers salary where `salary[i]` is the salary of the `i`th employee. Return the average salary of employees excluding the minimum and maximum salary.

## [Number of Arithmetic Slices](./code/numberOfArithmeticSlices.kt)
Given an integer array `nums`, return the number of arithmetic subarrays of `nums`.

## [Intersection](./code/intersection.kt)
Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.

## [First Unique Char](./code/firstUniqChar.kt)
Given a string `s`, find the first non-repeating character in it and return its index. If it does not exist, return `-1`.

## [Are Almost Equal](./code/areAlmostEqual.kt)
You are given two strings `s1` and `s2` of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return `true` if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return `false`.

## [Array Sign](./code/arraySign.kt)
You are given an integer array `nums`. Let `product` be the product of all values in the array `nums`. Return `signFunc(product)`.

## [Delete and Earn](./code/deleteAndEarn.kt)
You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:

    Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.

Return the maximum number of points you can earn by applying the above operation some number of times.

## [Sum Odd Length Subarrays](./code/sumOddLengthsSubarrays.kt)
Given an array of positive integers `arr`, calculate the sum of all possible odd-length subarrays. Return the sum of all odd-length subarrays of `arr`.

## [Matrix Reshape](./code/matrixReshape.kt)
In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.

You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.

The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.

If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.

## [Merge Alternatly](./code/mergeAlternatly.kt)
You are given two strings `word1` and `word2`. Merge the strings by adding letters in alternating order, starting with `word1`. If a string is longer than the other, append the additional letters onto the end of the merged string. Return the merged string.

## [Longest Palindrome 2](./code/longestPalindrome2.kt)
Given a string `s` which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, `"Aa"` is not considered a palindrome here.

## [Add Strings](./code/addStrings.kt)
Given two non-negative integers, `num1` and `num2` represented as string, return the sum of `num1` and `num2` as a string.

## [Read Binary Watch](./code/readBinaryWatch.kt)
A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. Given an integer `turnedOn` which represents the number of LEDs that are currently on, return all possible times the watch could represent. You may return the answer in any order.

## [To Hex](./code/toHex.kt)
Given an integer `num`, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.

## [Count Segments](./code/countSegments.kt)
Given a string `s`, return the number of segments in the string. A segment is defined to be a contiguous sequence of non-space characters.

## [Add to Array From](./code/addToArrayForm.kt)
The array-form of an integer `num` is an array representing its digits in left to right order. Given `num`, the array-form of an integer, and an integer `k`, return the array-form of the integer `num + k`.

## [Is Monotonic](./code/isMonotonic.kt)
An array is monotonic if it is either monotone increasing or monotone decreasing. An array `nums` is monotone increasing if for all `i <= j`, `nums[i] <= nums[j]`. An array nums is monotone decreasing if for all `i <= j`, `nums[i] >= nums[j]`. Given an integer array `nums`, return `true` if the given array is monotonic, or `false` otherwise.

## [License Key Formatting](./code/licenseKeyFormatting.kt)
You are given a license key represented as a string `s` that consists of only alphanumeric characters and dashes. The string is separated into `n + 1` groups by `n` dashes. You are also given an integer `k`. We want to reformat the string `s` such that each group contains exactly `k` characters, except for the first group, which could be shorter than `k` but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase. Return the reformatted license key.

## [Find K Distant Indices](./code/findKDistantIndices.kt)
You are given a `0`-indexed integer array `nums` and two integers `key` and `k`. A `k`-distant index is an index `i` of `nums` for which there exists at least one index `j` such that `abs(i - j) <= k` and `nums[j] == key`. Return a list of all `k`-distant indices sorted in increasing order.

## [Simplify Path](./code/simplifyPath.kt)
Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.

In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.

The canonical path should have the following format:

    + The path starts with a single slash '/'.
    + Any two directories are separated by a single slash '/'.
    + The path does not end with a trailing '/'.
    + The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')

Return the simplified canonical path.

## [Repeated Substring Pattern](./code/repeatedSubstringPattern.kt)
Given a string `s`, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.

## [Find Poisoned Duration](./code/findPoisonedDuration.kt)
Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly `duration` seconds. More formally, an attack at second `t` will mean Ashe is poisoned during the inclusive time interval `[t, t + duration - 1]`. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end `duration` seconds after the new attack.

You are given a non-decreasing integer array `timeSeries`, where `timeSeries[i]` denotes that Teemo attacks Ashe at second `timeSeries[i]`, and an integer `duration`.

Return the total number of seconds that Ashe is poisoned.

## [findWords](./code/findWords.kt)
Given an array of strings `words`, return the words that can be typed using letters of the alphabet on only one row of American keyboard.

## [Convert to Base 7](./code/converToBase7.kt)
Given an integer `num`, return a string of its base 7 representation.

## [Find Relative Ranks](./code/findRelativeRanks.kt)
You are given an integer array score of size `n`, where `score[i]` is the score of the `i`th athlete in a competition. All the scores are guaranteed to be unique.

The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:

    + The 1st place athlete's rank is "Gold Medal".
    + The 2nd place athlete's rank is "Silver Medal".
    + The 3rd place athlete's rank is "Bronze Medal".
    + For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is "x").

Return an array `answer` of size `n` where `answer[i]` is the rank of the ith athlete.

## [Score of Parentheses](./code/scoreOfParentheses.kt)
Given a balanced parentheses string `s`, return the score of the string.

## [Find Right Interval](./code/findRightInterval.kt)
You are given an array of `intervals`, where `intervals[i] = [starti, endi]` and each `starti` is unique. The right interval for an interval `i` is an interval `j` such that `startj >= endi` and `startj` is minimized. Return an array of right interval indices for each interval `i`. If no right interval exists for interval `i`, then put `-1` at index `i`.

## [Rotate](./code/rotate.kt)
You are given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

## [Find Rotation](./code/findRotation.kt)
Given two `n x n` binary matrices `mat` and `target`, return `true` if it is possible to make `mat` equal to `target` by rotating `mat` in 90-degree increments, or `false` otherwise.

## [Coun Collisions](./code/countCollisions.kt)
There are `n` cars on an infinitely long road. The cars are numbered from `0` to `n - 1` from left to right and each car is present at a unique point.

You are given a `0`-indexed string directions of length `n`. `directions[i]` can be either `'L'`, `'R'`, or `'S'` denoting whether the `i`th car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed.

The number of collisions can be calculated as follows:

    When two cars moving in opposite directions collide with each other, the number of collisions increases by 2.
    When a moving car collides with a stationary car, the number of collisions increases by 1.

After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.

Return the total number of collisions that will happen on the road.

## [Min Domino Rotations](./code/minDominoRotations.kt)
In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)

We may rotate the ith domino, so that tops[i] and bottoms[i] swap values.

Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same.

If it cannot be done, return -1.

## [Partition Labels](./code/partitionLabels.kt)
You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`. Return a list of integers representing the size of these parts.

## [Check Arithmetic Subarrays](./code/checkArithmeticSubarrays.kt)
A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence `s` is arithmetic if and only if `s[i+1] - s[i] == s[1] - s[0]` for all valid `i`. You are given an array of `n` integers, `nums`, and two arrays of `m` integers each, `l` and `r`, representing the `m` range queries, where the `i`th query is the range `[l[i], r[i]]`. All the arrays are `0`-indexed. Return a list of boolean elements `answer`, where `answer[i]` is `true` if the subarray `nums[l[i]], nums[l[i]+1], ... , nums[r[i]]` can be rearranged to form an arithmetic sequence, and `false` otherwise.

## [Get Smallest String](./code/getSmallestString.kt)
The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.

The numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string "abe" is equal to 1 + 2 + 5 = 8.

You are given two integers `n` and `k`. Return the lexicographically smallest string with length equal to `n` and numeric value equal to `k`.

Note that a string `x` is lexicographically smaller than string `y` if `x` comes before `y` in dictionary order, that is, either `x` is a prefix of `y`, or if `i` is the first position such that `x[i] != y[i]`, then `x[i]` comes before `y[i]` in alphabetic order.

## [Next Greater Element](./code/nextGreaterElement.kt)
Given a positive integer `n`, find the smallest integer which has exactly the same digits existing in the integer `n` and is greater in value than `n`. If no such positive integer exists, return `-1`. Note that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return `-1`.

## [Broken Calc](./code/brokenCalc.kt)
There is a broken calculator that has the integer `startValue` on its display initially. In one operation, you can: 1) multiply the number on display by `2`, or; 2) subtract `1` from the number on display. Given two integers `startValue` and `target`, return the minimum number of operations needed to display `target` on the calculator.

## [Num Subarray Product Less Than K](./code/numSubarrayProductLessThanK.kt)
Given an array of integers `nums` and an integer `k`, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than `k`.

## [Min Deletion](./code/minDeletion.kt)
You are given a `0`-indexed integer array `nums`. The array `nums` is beautiful if:

    nums.length is even.
    nums[i] != nums[i + 1] for all i % 2 == 0.

Note that an empty array is considered beautiful.

You can delete any number of elements from nums. When you delete an element, all the elements to the right of the deleted element will be shifted one unit to the left to fill the gap created and all the elements to the left of the deleted element will remain unchanged.

Return the minimum number of elements to delete from nums to make it beautiful.

## [Find Duplicate](./code/findDuplicate.kt)
Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive. There is only one repeated number in `nums`, return this repeated number. You must solve the problem without modifying the array `nums` and uses only constant extra space.

## [Lemondae Change](./code/lemonadeChange.kt)
At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.

Note that you do not have any change in hand at first.

Given an integer array `bills` where `bills[i]` is the bill the `i`th customer pays, return `true` if you can provide every customer with the correct change, or `false` otherwise.

## [AuthenticationManager](./code/AuthenticationManager.kt)
There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire `timeToLive` seconds after the `currentTime`. If the token is renewed, the expiry time will be extended to expire `timeToLive` seconds after the (potentially different) `currentTime`.

Implement the AuthenticationManager class:

    AuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.
    generate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.
    renew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.
    countUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.

Note that if a token expires at time `t`, and another action happens on time `t` (renew or `countUnexpiredTokens`), the expiration takes place before the other actions.

## [RandomizedSet](./code/RandomizedSet.kt)
Implement the RandomizedSet class:

    * RandomizedSet() Initializes the RandomizedSet object.
    * bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
    * bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
    * int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.

You must implement the functions of the class such that each function works in average O(1) time complexity.

## [Triangular Sum](./code/triangularSum.kt)
You are given a `0`-indexed integer array `nums`, where `nums[i]` is a digit between `0` and `9` (inclusive).

The triangular sum of `nums` is the value of the only element present in `nums` after the following process terminates:

    Let nums comprise of n elements. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n - 1.
    For each index i, where 0 <= i < n - 1, assign the value of newNums[i] as (nums[i] + nums[i+1]) % 10, where % denotes modulo operator.
    Replace the array nums with newNums.
    Repeat the entire process starting from step 1.

Return the triangular sum of `nums`.

## [Next permutation](./code/nextPermutation.kt)
A permutation of an array of integers is an arrangement of its members into a sequence or linear order.

    For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1].

The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

    For example, the next permutation of arr = [1,2,3] is [1,3,2].
    Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
    While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.

Given an array of integers `nums`, find the next permutation of `nums`.

The replacement must be in place and use only constant extra memory.

## [Convert Time](./code/convertTime.kt)
You are given two strings current and correct representing two `24`-hour times.

`24`-hour times are formatted as `"HH:MM"`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest `24`-hour time is `00:00`, and the latest is `23:59`.

In one operation you can increase the time current by `1`, `5`, `15`, or `60` minutes. You can perform this operation any number of times.

Return the minimum number of operations needed to convert current to correct.

## [Find Winners](./code/findWinners.kt)
You are given an integer array `matches` where `matches[i] = [winneri, loseri]` indicates that the player `winneri` defeated player `loseri` in a match.

Return a list answer of size `2` where:

    answer[0] is a list of all players that have not lost any matches.
    answer[1] is a list of all players that have lost exactly one match.

The values in the two lists should be returned in increasing order.

Note:

    You should only consider the players that have played at least one match.
    The testcases will be generated such that no two matches will have the same outcome.

## [Three Sum Multi](./code/threeSumMulti.kt)
Given an integer array `arr`, and an integer `target`, return the number of tuples `i`, `j`, `k` such that `i < j < k` and `arr[i] + arr[j] + arr[k] == target`. As the answer can be very large, return it modulo `10^9 + 7`.

## [Reverse Str](./code/reverseStr.kt)
Given a string `s` and an integer `k`, reverse the first `k` characters for every `2k` characters counting from the start of the string. If there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the other as original.

## [Check Record](./code/checkRecord.kt)
You are given a string `s` representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:

    'A': Absent.
    'L': Late.
    'P': Present.

The student is eligible for an attendance award if they meet both of the following criteria:

    The student was absent ('A') for strictly fewer than 2 days total.
    The student was never late ('L') for 3 or more consecutive days.

Return true if the student is eligible for an attendance award, or false otherwise.

## [Shift Grid](./code/shiftGrid.kt)
Given a 2D grid of size `m x n` and an integer `k`. You need to shift the grid `k` times. Return the 2D grid after applying shift operation `k` times.

## [Minimize Result](./code/minimizeResult.kt)
You are given a `0`-indexed string expression of the form `"<num1>+<num2>"` where `<num1>` and `<num2>` represent positive integers.

Add a pair of parentheses to expression such that after the addition of parentheses, expression is a valid mathematical expression and evaluates to the smallest possible value. The left parenthesis must be added to the left of '+' and the right parenthesis must be added to the right of '+'.

Return expression after adding a pair of parentheses such that expression evaluates to the smallest possible value. If there are multiple answers that yield the same result, return any of them.

The input has been generated such that the original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.

## [Game of Life](./code/gameOfLife.kt)
The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

    Any live cell with fewer than two live neighbors dies as if caused by under-population.
    Any live cell with two or three live neighbors lives on to the next generation.
    Any live cell with more than three live neighbors dies, as if by over-population.
    Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.

## [Generate Matrix](./code/generateMatrix.kt)
Given a positive integer `n`, generate an `n x n` matrix filled with elements from `1` to `n^2` in spiral order.

## [Find Closest Number](./code/findClosestNumber.kt)
Given an integer array `nums` of size `n`, return the number with the value closest to `0` in `nums`. If there are multiple answers, return the number with the largest value.

## [ATM](./code/ATM.kt)
There is an ATM machine that stores banknotes of 5 denominations: 20, 50, 100, 200, and 500 dollars. Initially the ATM is empty. The user can use the machine to deposit or withdraw any amount of money.

When withdrawing, the machine prioritizes using banknotes of larger values.

    For example, if you want to withdraw $300 and there are 2 $50 banknotes, 1 $100 banknote, and 1 $200 banknote, then the machine will use the $100 and $200 banknotes.
    However, if you try to withdraw $600 and there are 3 $200 banknotes and 1 $500 banknote, then the withdraw request will be rejected because the machine will first try to use the $500 banknote and then be unable to use banknotes to complete the remaining $100. Note that the machine is not allowed to use the $200 banknotes instead of the $500 banknote.

Implement the ATM class:

    ATM() Initializes the ATM object.
    void deposit(int[] banknotesCount) Deposits new banknotes in the order $20, $50, $100, $200, and $500.
    int[] withdraw(int amount) Returns an array of length 5 of the number of banknotes that will be handed to the user in the order $20, $50, $100, $200, and $500, and update the number of banknotes in the ATM after withdrawing. Returns [-1] if it is not possible (do not withdraw any banknotes in this case).

## [Minimum Rounds](./code/minimumRounds.kt)
You are given a `0`-indexed integer array `tasks`, where `tasks[i]` represents the difficulty level of a task. In each round, you can complete either `2` or `3` tasks of the same difficulty level. Return the minimum rounds required to complete all the tasks, or `-1` if it is not possible to complete all the tasks.

## [Digit Sum](./code/digitSum.kt)
You are given a string s consisting of digits and an integer k.

A round can be completed if the length of s is greater than k. In one round, do the following:

    Divide s into consecutive groups of size k such that the first k characters are in the first group, the next k characters are in the second group, and so on. Note that the size of the last group can be smaller than k.
    Replace each group of s with a string representing the sum of all its digits. For example, "346" is replaced with "13" because 3 + 4 + 6 = 13.
    Merge consecutive groups together to form a new string. If the length of the string is greater than k, repeat from step 1.

Return s after all rounds have been completed.

## [Backspace Compare](./code/backspaceCompare.kt)
Given two strings `s` and `t`, return `true` if they are equal when both are typed into empty text editors. `'#'` means a backspace character. Note that after backspacing an empty text, the text will continue empty.

## [MyHashMap](./code/MyHashMap.kt)
Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:

    MyHashMap() initializes the object with an empty map.
    void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
    int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
    void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.

## [Codec](./code/Codec.kt)
TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL.

There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.

Implement the Codec class:

    Codec() Initializes the object of the system.
    String encode(String longUrl) Returns a tiny URL for the given longUrl.
    String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object.

## [UndergroundSystem](./code/UndergroundSystem.kt)
An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.

Implement the UndergroundSystem class:

    void checkIn(int id, string stationName, int t)
        A customer with a card ID equal to id, checks in at the station stationName at time t.
        A customer can only be checked into one place at a time.
    void checkOut(int id, string stationName, int t)
        A customer with a card ID equal to id, checks out from the station stationName at time t.
    double getAverageTime(string startStation, string endStation)
        Returns the average time it takes to travel from startStation to endStation.
        The average time is computed from all the previous traveling times from startStation to endStation that happened directly, meaning a check in at startStation followed by a check out from endStation.
        The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation.
        There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.

You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order.

## [PeekingIterator](./code/PeekingIterator.kt)
Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.

Implement the PeekingIterator class:

    PeekingIterator(Iterator<int> nums) Initializes the object with the given integer iterator iterator.
    int next() Returns the next element in the array and moves the pointer to the next element.
    boolean hasNext() Returns true if there are still elements in the array.
    int peek() Returns the next element in the array without moving the pointer.

## [Minimum Average Difference](./code/minimumAverageDifference.kt)
You are given a `0`-indexed integer array `nums` of length `n`.

The average difference of the index `i` is the absolute difference between the average of the first `i + 1` elements of `nums` and the average of the last `n - i - 1` elements. Both averages should be rounded down to the nearest integer.

Return the index with the minimum average difference. If there are multiple such indices, return the smallest one.

Note:

    The absolute difference of two numbers is the absolute value of their difference.
    The average of n elements is the sum of the n elements divided (integer division) by n.
    The average of 0 elements is considered to be 0.

## [Count Unguarded](./code/countUnguarded.kt)
You are given two integers `m` and `n` representing a `0`-indexed `m x n` grid. You are also given two 2D integer arrays guards and walls where `guards[i] = [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the `i`th guard and `j`th wall respectively.

A guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.

Return the number of unoccupied cells that are not guarded.

## [Remove Digit](./code/removeDigit.kt)
You are given a string `number` representing a positive integer and a character `digit`. Return the resulting string after removing exactly one occurrence of `digit` from `number` such that the value of the resulting string in decimal form is maximized.

## [Count Distinct](./code/countDistinct.kt)
Given an integer array `nums` and two integers `k` and `p`, return the number of distinct subarrays which have at most `k` elements divisible by `p`.

## [Shuffle an Array](./code/shuffleAnArray.kt)
Given an integer array `nums`, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.

Implement the Solution class:

    Solution(int[] nums) Initializes the object with the integer array nums.
    int[] reset() Resets the array to its original configuration and returns it.
    int[] shuffle() Returns a random shuffling of the array.

## [Find Unsorted Subarray](./code/findUnsortedSubarray.kt)
Given an integer array `nums`, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return the shortest such subarray and output its length.

## [Max Operations](./code/maxOperations.kt)
You are given an integer array `nums` and an integer `k`. In one operation, you can pick two numbers from the array whose sum equals `k` and remove them from the array. Return the maximum number of operations you can perform on the array.

## [Max Points](./code/maxPoints.kt)
Given an array of points where `points[i] = [xi, yi]` represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.

## [Distribute Candies 2](./code/distributeCandies2.kt)
Alice has `n` candies, where the `i`th candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor. The doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice. Given the integer array `candyType` of length `n`, return the maximum number of different types of candies she can eat if she only eats `n / 2` of them.

## [Remove Duplicates](./code/removeDuplicates2.kt)
You are given a string `s` and an integer `k`, a `k` duplicate removal consists of choosing `k` adjacent and equal letters from `s` and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make `k` duplicate removals on `s` until we no longer can. Return the final string after all such duplicate removals have been made.

## [Find HLS](./code/findLHS.kt)
We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly `1`. Given an integer array `nums`, return the length of its longest harmonious subsequence among all its possible subsequences.

## [Find Restaurant](./code/findRestaurant.kt)
Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement.

## [Ways to Split Array](./code/waysToSplitArray.kt)
You are given a `0`-indexed integer array `nums` of length `n`.

`nums` contains a valid split at index `i` if the following are true:

    The sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.
    There is at least one element to the right of i. That is, 0 <= i < n - 1.

Return the number of valid splits in nums.

## [Divisor Substrings](./code/divisorSubstrings.kt)
The `k`-beauty of an integer `num` is defined as the number of substrings of `num` when it is read as a string that meet the following conditions:

    It has a length of k.
    It is a divisor of num.

Given integers `num` and `k`, return the `k`-beauty of `num`.

Note:

    Leading zeros are allowed.
    0 is not a divisor of any value.

A substring is a contiguous sequence of characters in a string.

## [Remove Anagrams](./code/removeAnagrams.kt)
You are given a `0`-indexed string array `words`, where `words[i]` consists of lowercase English letters. In one operation, select any index `i` such that `0 < i < words.length` and `words[i - 1]` and `words[i]` are anagrams, and delete `words[i]` from `words`. Keep performing this operation as long as you can select an index that satisfies the conditions. Return words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result.

## [Maximum Product](./code/maximumProduct.kt)
Given an integer array `nums`, find three numbers whose product is maximum and return the maximum product.

## [Longest Valid Parenthesis](./code/longestValidParenthesis.kt)
Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

## [Increasing Triplet](./code/increasingTriplet.kt)
Given an integer array `nums`, return `true` if there exists a triple of indices `(i, j, k)` such that `i < j < k` and `nums[i] < nums[j] < nums[k]`. If no such indices exists, return `false`.

## [Set Zeroes](./code/setZeroes.kt)
Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s.

## [Count and Say](./code/countAndSay.kt)
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:

    countAndSay(1) = "1"
    countAndSay(n) is the way you would "say" the digit string from countAndSay(n-1), which is then converted into a different digit string.

To determine how you "say" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.
Given a positive integer n, return the nth term of the count-and-say sequence.

## [Longest Concsecutive](./code/longestConsecutive.kt)
Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.

## [Find Repeated DNA Sequences](./code/findRepeatedDnaSequences.kt)
The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.

    For example, "ACGAATTCCG" is a DNA sequence.

When studying DNA, it is useful to identify repeated sequences within the DNA.

Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.

## [Max Product](./code/maxProduct.kt)
Given a string array `words`, return the maximum value of `length(word[i]) * length(word[j])` where the two words do not share common letters. If no such two words exist, return `0`.

## [Rearrange Characters](./code/rearrangeCharacters.kt)
You are given two `0`-indexed strings `s` and `target`. You can take some letters from `s` and rearrange them to form new strings. Return the maximum number of copies of `target` that can be formed by taking letters from `s` and rearranging them.

## [Discount Prices](./code/discountPrices.kt)
A sentence is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign '$'. A word represents a price if it is a non-negative real number preceded by a dollar sign.

    For example, "$100", "$23", and "$6.75" represent prices while "100", "$", and "2$3" do not.

You are given a string sentence representing a sentence and an integer discount. For each word representing a price, apply a discount of discount% on the price and update the word in the sentence. All updated prices should be represented with exactly two decimal places.

Return a string representing the modified sentence.

## [Largest Word Count](./code/largestWordCount.kt)
You have a chat log of `n` messages. You are given two string arrays `messages` and `senders` where `messages[i]` is a message sent by `senders[i]`.

A message is list of words that are separated by a single space with no leading or trailing spaces. The word count of a sender is the total number of words sent by the sender. Note that a sender may send more than one message.

Return the sender with the largest word count. If there is more than one sender with the largest word count, return the one with the lexicographically largest name.

Note:

    Uppercase letters come before lowercase letters in lexicographical order.
    "Alice" and "alice" are distinct.

## [Find Error Nums](./code/findErrorNums.kt)
You have a set of integers `s`, which originally contains all the numbers from `1` to `n`. Unfortunately, due to some error, one of the numbers in `s` got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array `nums` representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array.

## [Running Sum](./code/runningSum.kt)
Given an array `nums`. We define a running sum of an array as `runningSum[i] = sum(nums[0]…nums[i])`. Return the running sum of `nums`.

## [Min Max Game](./code/minMaxGame.kt)
You are given a `0`-indexed integer array `nums` whose length is a power of `2`.

Apply the following algorithm on nums:

    1) Let n be the length of nums. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n / 2.
    2) For every even index i where 0 <= i < n / 2, assign the value of newNums[i] as min(nums[2 * i], nums[2 * i + 1]).
    3) For every odd index i where 0 <= i < n / 2, assign the value of newNums[i] as max(nums[2 * i], nums[2 * i + 1]).
    4) Replace the array nums with newNums.
    5) Repeat the entire process starting from step 1.

Return the last number that remains in `nums` after applying the algorithm.

## [Array Change](./code/arrayChange.kt)
You are given a `0`-indexed array `nums` that consists of `n` distinct positive integers. Apply `m` operations to this array, where in the ith operation you replace the number `operations[i][0]` with `operations[i][1]`.

It is guaranteed that in the ith operation:

    + operations[i][0] exists in nums.
    + operations[i][1] does not exist in nums.

Return the array obtained after applying all the operations.

## [TextEditor](./code/TextEditor.kt)
Design a text editor with a cursor that can do the following:

    + Add text to where the cursor is.
    + Delete text from where the cursor is (simulating the backspace key).
    + Move the cursor either left or right.

When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that 0 <= cursor.position <= currentText.length always holds.

Implement the TextEditor class:

    + TextEditor() Initializes the object with empty text.
    + void addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.
    + int deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.
    + string cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.
    + string cursorRight(int k) Moves the cursor to the right k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.

## [Find Smallest Set Of Vertices](./code/findSmallestSetOfVertices.kt)
Given a directed acyclic graph, with `n` vertices numbered from `0` to `n-1`, and an array `edges` where `edges[i] = [fromi, toi]` represents a directed edge from node `fromi` to node `toi`. Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists. Notice that you can return the vertices in any order.

## [Remove Palindrome Sub](./code/removePalindromeSub.kt)
You are given a string `s` consisting only of letters `'a'` and `'b'`. In a single step you can remove one palindromic subsequence from `s`. Return the minimum number of steps to make the given string empty. A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous. A string is called palindrome if is one that reads the same backward as well as forward.

## [Min Operations](./code/minOperations.kt)
You are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this modifies the array for future operations. Return the minimum number of operations to reduce `x` to exactly `0` if it is possible, otherwise, return `-1`.

## [Maximum Unique Subarray](./code/maximumUniqueSubarray.kt)
You are given an array of positive integers `nums` and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements. Return the maximum score you can get by erasing exactly one subarray.

## [Insert Interval](./code/insertInterval.kt)
You are given an array of non-overlapping intervals intervals where `intervals[i] = [starti, endi]` represent the start and the end of the `i`th interval and intervals is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval. Insert `newInterval` into `intervals` such that intervals is still sorted in ascending order by `starti` and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return `intervals` after the insertion.

## [Check Possibility](./code/checkPossibility.kt)
Given an array `nums` with `n` integers, your task is to check if it could become non-decreasing by modifying at most one element. We define an array is non-decreasing if `nums[i] <= nums[i + 1]` holds for every `i` (`0`-based) such that (`0 <= i <= n - 2`).

## [Max Score](./code/maxScore.kt)
There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array `cardPoints`. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly `k` cards. Your score is the sum of the points of the cards you have taken. Given the integer array `cardPoints` and the integer `k`, return the maximum score you can obtain.

## [Decode Message](./code/decodeMessage.kt)
You are given the strings key and message, which represent a cipher key and a secret message, respectively. The steps to decode message are as follows:

    Use the first appearance of all 26 lowercase English letters in key as the order of the substitution table.
    Align the substitution table with the regular English alphabet.
    Each letter in message is then substituted using the table.
    Spaces ' ' are transformed to themselves.

    For example, given key = "happy boy" (actual key would have at least one instance of each letter in the alphabet), we have the partial substitution table of ('h' -> 'a', 'a' -> 'b', 'p' -> 'c', 'y' -> 'd', 'b' -> 'e', 'o' -> 'f').

Return the decoded message.

## [Spiral Matrix 4](./code/spiralMatrix4.kt)
You are given two integers `m` and `n`, which represent the dimensions of a matrix. You are also given the head of a linked list of integers. Generate an `m x n` matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with `-1`. Return the generated matrix.

## [Candy](./code/candy.kt)
You are giving candies to these children subjected to the following requirements:

    + Each child must have at least one candy.
    + Children with a higher rating get more candies than their neighbors.

Return the minimum number of candies you need to have to distribute the candies to the children.

## [Pivot Index](./code/pivotIndex.kt)
Given an array of integers `nums`, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right. If the index is on the left edge of the array, then the left sum is `0` because there are no elements to the left. This also applies to the right edge of the array. Return the leftmost pivot index. If no such index exists, return `-1`.

## [Number of Subarrays](./code/numberOfSubarrays.kt)
Given an array of integers `nums` and an integer `k`. A continuous subarray is called nice if there are `k` odd numbers on it. Return the number of nice sub-arrays.

## [Find Middle Index](./code/findMiddleIndex.kt)
Given a `0`-indexed integer array `nums`, find the leftmost `middleIndex` (i.e., the smallest amongst all the possible ones). A `middleIndex` is an index where `nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]`. If `middleIndex == 0`, the left side sum is considered to be `0`. Similarly, if `middleIndex == nums.length - 1`, the right side sum is considered to be `0`. Return the leftmost `middleIndex` that satisfies the condition, or `-1` if there is no such index.

## [SmallestInfiniteSet](./code/SmallestInfiniteSet.kt)
You have a set which contains all positive integers `[1, 2, 3, 4, 5, ...]`.

Implement the SmallestInfiniteSet class:

    + SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers.
    + int popSmallest() Removes and returns the smallest integer contained in the infinite set.
    + void addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set.

## [Move Pieces to Obtain a String](./code/movePiecesToObtainAString.kt)
You are given two strings start and target, both of length n. Each string consists only of the characters 'L', 'R', and '_' where:

    + The characters 'L' and 'R' represent pieces, where a piece 'L' can move to the left only if there is a blank space directly to its left, and a piece 'R' can move to the right only if there is a blank space directly to its right.
    + The character '_' represents a blank space that can be occupied by any of the 'L' or 'R' pieces.

Return true if it is possible to obtain the string target by moving the pieces of the string start any number of times. Otherwise, return false.

## [Number of Pairs](./code/numberOfPairs.kt)
You are given a `0`-indexed integer array `nums`. In one operation, you may do the following:

    + Choose two integers in nums that are equal.
    + Remove both integers from nums, forming a pair.

The operation is done on `nums` as many times as possible.

Return a `0`-indexed integer array answer of size 2 where `answer[0]` is the number of pairs that are formed and `answer[1]` is the number of leftover integers in nums after doing the operation as many times as possible.

## [Maximum Sum](./code/maximumSum.kt)
You are given a `0`-indexed array `nums` consisting of positive integers. You can choose two indices `i` and `j`, such that `i != j`, and the sum of digits of the number `nums[i]` is equal to that of `nums[j]`. Return the maximum value of `nums[i] + nums[j]` that you can obtain over all possible indices `i` and `j` that satisfy the conditions.

## [NUm Submatrix Sum Target](./code/numSubmatrixSumTarget.kt)
Given a `matrix` and a `target`, return the number of non-empty submatrices that sum to `target`. A submatrix `x1, y1, x2, y2` is the set of all cells `matrix[x][y]` with `x1 <= x <= x2` and `y1 <= y <= y2`. Two submatrices `(x1, y1, x2, y2)` and `(x1', y1', x2', y2')` are different if they have some coordinate that is different: for example, if `x1 != x1'`.

## [Best Hand](./code/bestHand.kt)
You are given an integer array ranks and a character array suits. You have 5 cards where the ith card has a rank of ranks[i] and a suit of suits[i].

The following are the types of poker hands you can make from best to worst:

    "Flush": Five cards of the same suit.
    "Three of a Kind": Three cards of the same rank.
    "Pair": Two cards of the same rank.
    "High Card": Any single card.

Return a string representing the best type of poker hand you can make with the given cards.

Note that the return values are case-sensitive.

## [Zero Filled Subarray](./code/zeroFilledSubarray.kt)
Given an integer array `nums`, return the number of subarrays filled with `0`. A subarray is a contiguous non-empty sequence of elements within an array.

## [NumberContainers](./code/NumberContainers.kt)
Design a number container system that can do the following:

    Insert or Replace a number at the given index in the system.
    Return the smallest index for the given number in the system.

Implement the NumberContainers class:

    NumberContainers() Initializes the number container system.
    void change(int index, int number) Fills the container at index with the number. If there is already a number at that index, replace it.
    int find(int number) Returns the smallest index for the given number, or -1 if there is no index that is filled by number in the system.

## [Repeated Character](./code/repeatedCharacter.kt)
Given a string s consisting of lowercase English letters, return the first letter to appear twice.

Note:

    A letter a appears twice before another letter b if the second occurrence of a is before the second occurrence of b.
    s will contain at least one letter that appears twice.

## [Equal Pairs](./code/equalPairs.kt)
Given a `0`-indexed `n x n` integer matrix grid, return the number of pairs `(Ri, Cj)` such that row `Ri` and column `Cj` are equal. A row and column pair is considered equal if they contain the same elements in the same order (i.e. an equal array).

## [FoodRatings](./code/FoodRatings.kt)
Design a food rating system that can do the following:

    Modify the rating of a food item listed in the system.
    Return the highest-rated food item for a type of cuisine in the system.

Implement the FoodRatings class:

    FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.
        foods[i] is the name of the ith food,
        cuisines[i] is the type of cuisine of the ith food, and
        ratings[i] is the initial rating of the ith food.
    void changeRating(String food, int newRating) Changes the rating of the food item with the name food.
    String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. If there is a tie, return the item with the lexicographically smaller name.

Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.

## [Sort Colors](./code/sortColors.kt)
Given an array `nums` with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.

## [Word Subsets](./code/wordSubsets.kt)
You are given two string arrays `words1` and `words2`. A string `b` is a subset of string `a` if every letter in `b` occurs in a including multiplicity. A string `a` from `words1` is universal if for every string `b` in `words2`, `b` is a subset of `a`. Return an array of all the universal strings in `words1`. You may return the answer in any order.

## [Minimum Operations](./code/minimumOperations.kt)
You are given a non-negative integer array `nums`. In one operation, you must:

    Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.
    Subtract x from every positive element in nums.

Return the minimum number of operations to make every element in `nums` equal to `0`.


## [Compress](./code/compress.kt)
Given an array of characters chars, compress it using the following algorithm:

Begin with an empty string s. For each group of consecutive repeating characters in chars:

    If the group's length is 1, append the character to s.
    Otherwise, append the character followed by the group's length.

The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.

After you are done modifying the input array, return the new length of the array.

You must write an algorithm that uses only constant extra space.

## [Task Scheduler II](./code/taskSchedulerII.kt)
You are given a `0`-indexed array of positive integers `tasks`, representing tasks that need to be completed in order, where `tasks[i]` represents the type of the `i`th task.

You are also given a positive integer space, which represents the minimum number of days that must pass after the completion of a task before another task of the same type can be performed.

Each day, until all tasks have been completed, you must either:

    Complete the next task from tasks, or
    Take a break.

Return the minimum number of days needed to complete all tasks.

## [Edge Score](./code/edgeScore.kt)
You are given a directed graph with `n` nodes labeled from `0` to `n - 1`, where each node has exactly one outgoing edge. The graph is represented by a given `0`-indexed integer array `edges` of length `n`, where `edges[i]` indicates that there is a directed edge from node `i` to node `edges[i]`. The edge score of a node `i` is defined as the sum of the labels of all the nodes that have an edge pointing to `i`. Return the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.

## [Is Possible](./code/isPossible.kt)
You are given an integer array nums that is sorted in non-decreasing order.

Determine if it is possible to split nums into one or more subsequences such that both of the following conditions are true:

    Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).
    All subsequences have a length of 3 or more.

Return true if you can split nums according to the above conditions, or false otherwise.

A subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not).

## [Largest Palindromic](./code/largestPalindromic.kt)
You are given a string num consisting of digits only.

Return the largest palindromic integer (in the form of a string) that can be formed using digits taken from num. It should not contain leading zeroes.

Notes:

    You do not need to use all the digits of num, but you must use at least one digit.
    The digits can be reordered.

## [Min Number of Hours](./code/minNumberOfHours.kt)
You are entering a competition, and are given two positive integers `initialEnergy` and `initialExperience` denoting your initial energy and initial experience respectively.

You are also given two `0`-indexed integer arrays energy and experience, both of length `n`.

You will face `n` opponents in order. The energy and experience of the `i`th opponent is denoted by `energy[i]` and `experience[i]` respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available.

Defeating the `i`th opponent increases your experience by `experience[i]`, but decreases your energy by `energy[i]`.

Before starting the competition, you can train for some number of hours. After each hour of training, you can either choose to increase your initial experience by one, or increase your initial energy by one.

Return the minimum number of training hours required to defeat all `n` opponents.

## [Minimum Recolors](./code/minimumRecolors.kt)
You are given a `0`-indexed string `blocks` of length `n`, where `blocks[i]` is either `'W'` or `'B'`, representing the color of the `i`th block. The characters `'W'` and `'B'` denote the colors white and black, respectively.

You are also given an integer `k`, which is the desired number of consecutive black blocks.

In one operation, you can recolor a white block such that it becomes a black block.

Return the minimum number of operations needed such that there is at least one occurrence of `k` consecutive black blocks.

## [Reordered Power of 2](./code/reorderedPowerOf2.kt)
You are given an integer `n`. We reorder the digits in any order (including the original order) such that the leading digit is not zero. Return `true` if and only if we can do this so that the resulting number is a power of two.

## [Diagonal Sort](./code/diagonalSort.kt)
A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. For example, the matrix diagonal starting from `mat[2][0]`, where mat is a `6 x 3` matrix, includes cells `mat[2][0]`, `mat[3][1]`, and `mat[4][2]`. Given an `m x n` matrix `mat` of integers, sort each matrix diagonal in ascending order and return the resulting matrix.

## [Garbage Collection](./code/garbageCollection.kt)
You are given a `0`-indexed array of strings garbage where `garbage[i]` represents the assortment of garbage at the `i`th house. `garbage[i]` consists only of the characters `'M'`, `'P'` and `'G'` representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes `1` minute. You are also given a `0`-indexed integer array `travel` where `travel[i]` is the number of minutes needed to go from house `i` to house `i + 1`. There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house `0` and must visit each house in order; however, they do not need to visit every house. Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything. Return the minimum number of minutes needed to pick up all the garbage.

## [Remove Stars](./code/removeStars.kt)
You are given a string s, which contains stars *.

In one operation, you can:

    Choose a star in s.
    Remove the closest non-star character to its left, as well as remove the star itself.

Return the string after all stars have been removed.

Note:

    The input will be generated such that the operation is always possible.
    It can be shown that the resulting string will always be unique.

## [Find Subarrays](./code/findSubarrays.kt)
Given a `0`-indexed integer array `nums`, determine whether there exist two subarrays of length `2` with equal sum. Note that the two subarrays must begin at different indices. Return `true` if these subarrays exist, and `false` otherwise. A subarray is a contiguous non-empty sequence of elements within an array.

## [Check Distances](./code/checkDistances.kt)
You are given a `0`-indexed string `s` consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a `0`-indexed integer array distance of length `26`.

Each letter in the alphabet is numbered from `0` to `25` (i.e. `'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25`).

In a well-spaced string, the number of letters between the two occurrences of the `i`th letter is `distance[i]`. If the `i`th letter does not appear in `s`, then `distance[i]` can be ignored.

Return `true` if `s` is a well-spaced string, otherwise return `false`.

## [Min Window](./code/minWindow.kt)
Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `""`. The testcases will be generated such that the answer is unique. A substring is a contiguous sequence of characters within the string.

## [Number of Weak Characters](./code/numberOfWeakCharacters.kt)
You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array `properties` where `properties[i] = [attacki, defensei]` represents the properties of the `i`th character in the game. A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character `i` is said to be weak if there exists another character `j` where `attackj > attacki` and `defensej > defensei`. Return the number of weak characters.

## [Most Frequent Even](./code/mostFrequentEven.kt)
Given an integer array `nums`, return _the most frequent even element_. If there is a tie, return the **smallest** one. If there is no such element, return `-1`.

## [Partition String](./code/partitionString.kt)
Given a string `s`, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once. Return the minimum number of substrings in such a partition. Note that each character should belong to exactly one substring in a partition.

## [Valid UTF-8](./code/validUtf8.kt)
Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).

A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:

    For a 1-byte character, the first bit is a 0, followed by its Unicode code.
    For an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.

This is how the UTF-8 encoding would work:

     Number of Bytes   |        UTF-8 Octet Sequence
                       |              (binary)
   --------------------+-----------------------------------------
            1          |   0xxxxxxx
            2          |   110xxxxx 10xxxxxx
            3          |   1110xxxx 10xxxxxx 10xxxxxx
            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

x denotes a bit in the binary form of a byte that may be either 0 or 1.

Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.

## [Find Original Array](./code/findOriginalArray.kt)
An integer array `original` is transformed into a doubled array `changed` by appending twice the value of every element in `original`, and then randomly shuffling the resulting array. Given an array `changed`, return `original` if `changed` is a doubled array. If changed is not a doubled array, return an empty array. The elements in `original` may be returned in any order.

## [Longest Continuous Substring](./code/longestContinuousSubstring.kt)
An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string `"abcdefghijklmnopqrstuvwxyz"`. Given a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring.

## [Smallest Subarrays](./code/smallestSubarrays.kt)
You are given a `0`-indexed array `nums` of length `n`, consisting of non-negative integers. For each index `i` from `0` to `n - 1`, you must determine the size of the minimum sized non-empty subarray of `nums` starting at `i` (inclusive) that has the maximum possible bitwise OR.

    In other words, let Bij be the bitwise OR of the subarray nums[i...j]. You need to find the smallest subarray starting at i, such that bitwise OR of this subarray is equal to max(Bik) where i <= k <= n - 1.

The bitwise OR of an array is the bitwise OR of all the numbers in it.

Return an integer array answer of size `n` where `answer[i]` is the length of the minimum sized subarray starting at `i` with maximum bitwise OR.

A subarray is a contiguous non-empty sequence of elements within an array.

## [Count Days Together](./code/countDaysTogether.kt)
Alice and Bob are traveling to Rome for separate business meetings.

You are given 4 strings arriveAlice, leaveAlice, arriveBob, and leaveBob. Alice will be in the city from the dates arriveAlice to leaveAlice (inclusive), while Bob will be in the city from the dates arriveBob to leaveBob (inclusive). Each will be a 5-character string in the format "MM-DD", corresponding to the month and day of the date.

Return the total number of days that Alice and Bob are in Rome together.

You can assume that all dates occur in the same calendar year, which is not a leap year. Note that the number of days per month can be represented as: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31].

## [Sum Event After Queries](./code/sumEvenAfterQueries.kt)
You are given an integer array `nums` and an array `queries` where `queries[i] = [vali, indexi]`. For each query `i`, first, apply `nums[indexi] = nums[indexi] + vali`, then print the sum of the even values of `nums`. Return an integer array `answer` where `answer[i]` is the answer to the `i`th query.

## [Equation Possible](./code/equationPossible.kt)
You are given an array of strings `equations` that represent relationships between variables where each string `equations[i]` is of length `4` and takes one of two different forms: `"xi==yi"` or `"xi!=yi"`.Here, `xi` and `yi` are lowercase letters (not necessarily different) that represent one-letter variable names. Return `true` if it is possible to assign integers to variable names so as to satisfy all the given equations, or `false` otherwise.

## [Good Indices](./code/goodIndices.kt)
You are given a 0-indexed integer array nums of size n and a positive integer k.

We call an index i in the range k <= i < n - k good if the following conditions are satisfied:

    The k elements that are just before the index i are in non-increasing order.
    The k elements that are just after the index i are in non-decreasing order.

Return an array of all good indices sorted in increasing order.

## [Longest Subarray](./code/longestSubarray.kt)
You are given an integer array nums of size n.

Consider a non-empty subarray from nums that has the maximum possible bitwise AND.

    In other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered.

Return the length of the longest such subarray.

The bitwise AND of an array is the bitwise AND of all the numbers in it.

A subarray is a contiguous sequence of elements within an array.

## [Min Cost](./code/minCost.kt)
Alice has `n` balloons arranged on a rope. You are given a `0`-indexed string `colors` where `colors[i]` is the color of the `i`th balloon. Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a `0`-indexed integer array `neededTime` where `neededTime[i]` is the time (in seconds) that Bob needs to remove the `i`th balloon from the rope. Return the minimum time Bob needs to make the rope colorful.

## [Max Sum](./code/maxSum.kt)
You are given an `m x n` integer matrix `grid`. Return the maximum sum of the elements of an hourglass. Note that an hourglass cannot be rotated and must be entirely contained within the matrix.

## [Check if Pangram](./code/checkIfPangram.kt)
A pangram is a sentence where every letter of the English alphabet appears at least once. Given a string `sentence` containing only lowercase English letters, return `true` if `sentence` is a pangram, or `false` otherwise.

## [Distinct Names](./code/distinctNames.kt)
You are given an array of strings `ideas` that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:

    Choose 2 distinct names from ideas, call them ideaA and ideaB.
    Swap the first letters of ideaA and ideaB with each other.
    If both of the new names are not found in the original ideas, then the name ideaA ideaB (the concatenation of ideaA and ideaB, separated by a space) is a valid company name.
    Otherwise, it is not a valid name.

Return the number of distinct valid names for the company.